#!/bin/sh
MNT="$HOME/mnt"
DEST="$HOME/Dokumente"
DOKP="$MNT/DokPers"
SOFTW="$MNT/Software"
IMG="$HOME/.imgs"; if [ ! -e "$IMG" ]; then mkdir -p "$IMG"; fi
BKP0="/media/zapata/Volume/BCKP/backup0"
chk=`df -h | grep zapDokPers | wc -l`
chkDokp=`df -h | grep zapDokPers | wc -l`
chkSoftw=`df -h | grep zapSoftw | wc -l`
chkDiscVol=`ls -l /dev/disk/by-uuid | grep 2F4025F868E8C3A8 | wc -l`
options="{ start | stop | decrypt | create }"

##########################################################
##########################################################
echo "Dieses Skript benötigt Superuser Rechte"
if [ `dpkg-query --show | grep aes | wc -l` = 0 ];then sudo apt-get install loop-aes-utils; fi
sudo modprobe cryptoloop
sudo modprobe aes

case $1 in
    start|"")
        ##### Einhängen der Iso Images ###########################
        ##########################################################
        case $chk in
            "2")
                echo ""
                echo "Beide Images sind bereits gemountet!"
                exit 1
                ;;
            "1")
                if [ $chkDokp = 1 ];then
                    echo ""
                    echo "DokPers ist bereits gemountet!"; sleep 1
                    read -p "Willst du den Ordner *Software* mounten (Y|n)? " answersoftw
                    case $answersoftw in
                        "Y"|"")
                            answer="S"
                            ;;
                        "n")
                            echo "Skript wird beendet."
                            exit 0
                            ;;
                    esac
                fi
                if [ $chkSoftw = 1 ];then
                    echo ""
                    echo "Software ist bereits gemountet!"; sleep 1
                    read -p "Willst du DokPers mounten (Y|n)? " answerdokp
                    case $answerdokp in
                        "Y"|"")
                            answer="D"
                            ;;
                        "n")
                            echo "Skript wird beendet."
                            exit 0
                            ;;
                    esac
                fi
                ;;
            "0")
                echo "Welches Image-File soll gemountet werden?\n\nDokPers (D) | Software (S) | Abbrechen (exit) \nAntwort: " 
                read answer
                ;;
        esac

        case $answer in
            "D")
                if [ ! -e $DOKP ]; then sudo mkdir -p $DOKP; fi
                sudo echo "Gib jetzt das Passwort für das Image *DokPers* ein..."
                sudo mount $IMG/zapDokPers.img -t ext2 -w -o acl,user_xattr,loop=/dev/loop0,owner,encryption=AES256,gpgkey=$IMG/zapKey.asc $MNT/DokPers
                ;;
            "S")
                if [ ! -e $SOFTW ]; then sudo mkdir -p $SOFTW; fi
                sudo echo "Gib jetzt das Passwort für das Image *Software* ein..."
                sudo mount $IMG/zapSoftw.img -t ext2 -w -o acl,user_xattr,loop=/dev/loop1,owner,encryption=AES256,gpgkey=$IMG/zapKey.asc $SOFTW
                ;;
            exit|*)
                echo "Image-Datei einhängen abgebrochen!"
                exit 0
                ;;
        esac
        ;;

    create)
        read -p "Möchtest du ein Sparse-Image anlegen? (Y|n) " answer
        case "$answer" in
            Yes|yes|Y|y|"") 
                type="sparse"
                ;;
            No|no|N|n) 
                type="regular"
                ;;
        esac
        sleep 1

        read -p "Wie soll die Image-Datei heißen? " imgfile
        read -p "Wie groß (GB) soll die Image-Datei werden? " imgsize
        echo "Img $imgfile wird erstellt ..."
        case `sudo losetup -f` in
            "/dev/loop0")
                loopdev="/dev/loop0"
                ;;
            "/dev/loop1")
                loopdev="/dev/loop1"
                ;;
            *)
                read -p "Wie soll das Image-File heißen? " imgfile
                read -p "Wie groß soll es bei maximaler Auslastung sein (GB)? " imgsize
                ;;
        esac

        if [ ! -e $IMG/zapKey.asc ]; then

            ### Erneutes Generieren eines Passworts ###
            ###########################################
            echo ""
            echo "Kopiere das Passwort und bestätige es zweimal"
            abfrage ()
            {
                read -p "Möchtest du ein neues Passwort? (Y|n)? " answer
                case "$answer" in
                    Yes|yes|Y|y|"") echo "Ok los geht's"
                        pssw
                        ;;
                    No|no|N|n) echo "Bitte obiges Passwort kopieren und in Passwort-Agenten eintragen"
                        sleep 2
                        ;;
                esac
            }

            pssw () 
            {
                echo `< /dev/urandom tr -dc _A-Z-a-z-0-9 | head -c8`
                abfrage
            }
            pssw

            apg -a 1 -n 1 -m 23 -x 65 | gpg --symmetric -a > $IMG/zapKey.asc
        fi


        ### Erzeugen der Imagedate ################
        ###########################################
        case "$type" in
            "sparse")
                #sudo dd if=/dev/zero of=$IMG/zap$imgfile.img bs=1024 count=0 seek="$imgsize"
                sudo dd if=/dev/zero of=$IMG/zap$imgfile.img bs=1024 count=0 seek=$(($imgsize * 1024 * 1024))
                ;;
            "regular")
                sudo dd if=/dev/zero of=Platte.img bs=1024k count=$(($imgsize * 1024 * 1024))
                ;;
        esac
        sudo losetup -f
        sudo losetup -e AES256 -K $IMG/zapKey.asc $loopdev $IMG/zap$imgfile.img
        #sudo mkfs.ext2 $loopdev
        sudo mkfs -t ext2 $loopdev
        if [ ! -e $MNT/$imgfile ]; then mkdir -p $MNT/$imgfile; fi
        sudo mount $IMG/zap$imgfile.img -o rw,owner,loop=$loopdev,encryption=AES256,gpgkey=$IMG/zapKey.asc $MNT/$imgfile -t ext2
        sudo chown -R `whoami` $MNT/$imgfile #Gibt Benutzerrechte frei.
        echo "Das Image jetzt zugänglich im Ordner $MNT/$imgfile."
        sleep 3
        if [ $chkDiscVol = 1 ]; then
            read -p "Willst du die neue Image in deinen Backup-Ordner kopieren (Y|n)? " answer
            case $answer in
                Yes|yes|Y|y|"") echo "Ok los geht's"
                    cp -v --sparse $IMG/zap$imgfile.img $BKP0/.imgs/
                    echo -e "Datei erfolgreich gesichert!\nSkript wird beendet."
                    exit 0
                    ;;
                No|no|N|n) echo "Image-File erfolgreich erstellt!"
                    exit 1
                    ;;
                *) echo "Unbekannter Parameter" 
                    ;;
            esac
        else
            echo ""
            echo "Festplatte *Volume* ist derzeit nicht eingehängt"
            echo "Kopiere die Datei später in den Backup-Ordner mit\ncp --sparse IN OUT"
            sleep 1
            echo "bye bye!"
            exit 1
        fi
        ;;

    stop)
        ##### Aushängen der Iso Images ###########################
        ##########################################################
        if [ $chk = 0 ]; then
            echo ""
            echo "Beide Images sind bereits ausgehängt!"
            echo "Wähle eine andere Option: $0 $options"
            exit 1
        fi
        #### Aushängen des Ordners DokPers
        ##################################
        if [ $chkDokp = 0 ];then
            echo "Ordner *DokPers* ist nicht eingehängt."
        else
            read -p "Willst du eine Sicherung der Persönlichen Dokumente herstellen (Y|n)? " answer
            case $answer in
                Y|Yes|y|yes)
                    rsync -rvu --delete $DOKP /tmp/
                    cd /tmp/
                    tar -cvf DokPers.tar ./DokPers/  #legt ein Tar-Archiv der persönlichen Dokumente an.
                    yes j | gpg -e -a -r DokPers DokPers.tar #Verschlüsselt das angelegte Archiv
                    cp -v DokPers.tar.asc $DEST
                    rm -r /tmp/DokPers* #Löschen der im $Home-Ordner abgelegten Dateien
                    notify-send "Persönlichen Dokumente erfolgreich gesichert!"
                    cd $HOME
                    ;;
                n)
                    echo "Daten sichern übersprungen!"
                    ;;
            esac
            echo "Image *DokPers* wird ausgehängt."
            sudo umount $DOKP #Aushängen der gemounteten Image und anschl. löschen des Ordners.
            sudo rmdir $DOKP
        fi
        #### Aushängen des Ordners Software
        ###################################
        if [ $chkSoftw = 0 ];then
            echo "Image *Software* ist nicht eingehängt."
        else
            echo "Image *Software* wird ausgehängt."
            sudo umount $SOFTW #Aushängen der gemounteten Image und anschl. löschen des Ordners.
            sudo rmdir $SOFTW
        fi
        exit 0
        ;;

    decrypt)
        echo "Bitte gib den Namen der Datei im aktuellen Verzeichnis an. "
        read -e file
        ext=`basename $2 | sed 's/.*\.\(\w*\)\.\w*$/\1/g'`
        bas=${file%%.*}
        #ext=`basename $2 | sed 's/\.*\w*\.\(.*\)\..*$/\1/g'`
        #cpio -it -F $bas.$ext #listet Dateien im Archiv auf
        #cpio -idv -F $bas.$ext #Extrahiert aus dem Archiv

        ##### Enstschlüsseln verschlüsselter Sicherungen #########
        ##########################################################
        gpg -d -o $bas.$ext $file #Entschlüsselt verschlüsselte Datei mittels geheimer Passphrase
        case $ext in
            tar)
                echo "Auflistung des Archivs in 3 sec"
                sleep 3
                echo -e "`tar tvf $bas.$ext | sed '3q'` \n\netc."

                read -p "Möchtest du die Datei extrahieren (Y|n)? " file
                case $file in
                    Yes|yes|Y|y|"") echo "Ok los geht's"
                        tar xvf $bas.$ext
                        ;;
                    No|no|N|n) echo "Abbruch."
                        exit 1
                        ;;
                    *) echo "Unbekannter Parameter" 
                        ;;
                esac
        esac
        ;;
    help|"-h"|"--help")
        echo "Benutzung: $0 $options"
        ;;
esac
exit 0
